#line 1 "C:\\Users\\chadgroves\\OneDrive - Simventions, Inc\\Desktop\\ShootingAssistant_V4\\backup\\ui_Bubble_Level_Page.c"
// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"              // Main UI include from SquareLine Studio
#include "ui_modern_theme.h" // DEADEYE theme support

// Additional includes for bubble level functionality
#include <stdio.h> // For snprintf
#include <math.h>  // For fabsf

// --- Color threshold constants ---
#define BUBBLE_LEVEL_THRESHOLD_GREEN 3.0f
#define BUBBLE_LEVEL_THRESHOLD_YELLOW 8.0f

// --- Definitions for the Bubble Level ---
#define LEVEL_CANVAS_WIDTH 200
#define LEVEL_CANVAS_HEIGHT 40
#define TUBE_WIDTH (LEVEL_CANVAS_WIDTH - 10)   // Tube width is 190
#define TUBE_HEIGHT (LEVEL_CANVAS_HEIGHT - 10) // Tube height is 20
#define TUBE_BORDER_RADIUS 8
// MODIFIED: New Bubble Dimensions for an Oval
#define BUBBLE_HEIGHT (TUBE_HEIGHT - 2)   // Bubble height remains 14 (to fit tube)
#define BUBBLE_WIDTH (BUBBLE_HEIGHT + 12) // Make bubble wider, e.g., 14 + 8 = 22. Adjust as you like.
#define MAX_ROLL_ANGLE 30.0f

// --- Colors for the Bubble Level - DEADEYE Theme ---
// These are static to this file
static lv_color_t color_page_bg_bubble;
static lv_color_t color_tube_bg_bubble;
static lv_color_t color_bubble_green;
static lv_color_t color_bubble_yellow;
static lv_color_t color_bubble_red;
static lv_color_t color_text_roll_label;
static lv_color_t color_tube_marking_bubble;

// --- LVGL Objects for the Bubble Level (static to this file/module) ---
// These are specific to the bubble level functionality on this page
static lv_obj_t *ui_BubbleLevelCanvas = NULL;    // Initialize to NULL
static lv_obj_t *ui_RollAngleLabel = NULL;       // Initialize to NULL
static lv_timer_t *ui_level_update_timer = NULL; // Timer for updates, initialize to NULL

// --- Forward declarations for bubble level helper functions ---
static void draw_bubble_level_on_canvas(float roll_angle_deg);
static void level_update_timer_cb(lv_timer_t *timer);

// --- SquareLine Studio Global Variables (defined in this file by SLS) ---
lv_obj_t *ui_Bubble_Level_Page;
lv_obj_t *ui_BubbleLevelPageLabel;
lv_obj_t *ui_Page1HomeBTN;
lv_obj_t *ui_Pg1HomeBTN;
lv_obj_t *ui_Page1NextBTN1;
lv_obj_t *ui_Page1NextBTN;
lv_obj_t *ui_Page1PrevBTN;
lv_obj_t *ui_Page1PrevBTN1;

// --- Event functions (from your provided .c file) ---
void ui_event_Page1HomeBTN(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_PRESSED)
    {
        // Assuming _ui_screen_change and ui_Options_Page are defined in ui.h or elsewhere
        _ui_screen_change(&ui_Options_Page, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 500, 0, &ui_Options_Page_screen_init);
    }
}

void ui_event_Page1NextBTN1(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_PRESSED)
    {
        // Assuming _ui_screen_change and ui_Artificial_Horizon_Page are defined
        _ui_screen_change(&ui_Artificial_Horizon_Page, LV_SCR_LOAD_ANIM_MOVE_LEFT, 500, 0,
                          &ui_Artificial_Horizon_Page_screen_init);
    }
}

void ui_event_Page1PrevBTN(lv_event_t *e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_PRESSED)
    {
        // Assuming _ui_screen_change and ui_Options_Page are defined
        _ui_screen_change(&ui_Options_Page, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 500, 0, &ui_Options_Page_screen_init);
    }
}

// --- Build functions (screen_init from your provided .c file) ---
void ui_Bubble_Level_Page_screen_init(void)
{
    ui_Bubble_Level_Page = lv_obj_create(NULL);
    lv_obj_clear_flag(ui_Bubble_Level_Page, LV_OBJ_FLAG_SCROLLABLE); /// Flags

    // Apply DEADEYE theme
    ui_modern_theme_apply_page_background(ui_Bubble_Level_Page);

    ui_BubbleLevelPageLabel = lv_label_create(ui_Bubble_Level_Page);
    lv_obj_set_width(ui_BubbleLevelPageLabel, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height(ui_BubbleLevelPageLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_BubbleLevelPageLabel, 0);
    lv_obj_set_y(ui_BubbleLevelPageLabel, -125); // Adjusted Y from your file
    lv_obj_set_align(ui_BubbleLevelPageLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_BubbleLevelPageLabel, "DEADEYE BUBBLE LEVEL");
    ui_modern_theme_apply_title_style(ui_BubbleLevelPageLabel);

    ui_Page1HomeBTN = lv_btn_create(ui_Bubble_Level_Page);
    lv_obj_set_width(ui_Page1HomeBTN, 50);
    lv_obj_set_height(ui_Page1HomeBTN, 25);
    lv_obj_set_x(ui_Page1HomeBTN, -60);
    lv_obj_set_y(ui_Page1HomeBTN, 125);
    lv_obj_set_align(ui_Page1HomeBTN, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_Page1HomeBTN, LV_OBJ_FLAG_SCROLL_ON_FOCUS); /// Flags
    lv_obj_clear_flag(ui_Page1HomeBTN, LV_OBJ_FLAG_SCROLLABLE);    /// Flags
    ui_modern_theme_apply_button_style(ui_Page1HomeBTN);

    ui_Pg1HomeBTN = lv_label_create(ui_Page1HomeBTN);
    lv_obj_set_width(ui_Pg1HomeBTN, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height(ui_Pg1HomeBTN, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_Pg1HomeBTN, LV_ALIGN_CENTER);
    lv_label_set_text(ui_Pg1HomeBTN, "HOME");

    ui_Page1NextBTN1 = lv_btn_create(ui_Bubble_Level_Page);
    lv_obj_set_width(ui_Page1NextBTN1, 50);
    lv_obj_set_height(ui_Page1NextBTN1, 25);
    lv_obj_set_x(ui_Page1NextBTN1, 60);
    lv_obj_set_y(ui_Page1NextBTN1, 125);
    lv_obj_set_align(ui_Page1NextBTN1, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_Page1NextBTN1, LV_OBJ_FLAG_SCROLL_ON_FOCUS); /// Flags
    lv_obj_clear_flag(ui_Page1NextBTN1, LV_OBJ_FLAG_SCROLLABLE);    /// Flags
    ui_modern_theme_apply_button_style(ui_Page1NextBTN1);

    ui_Page1NextBTN = lv_label_create(ui_Page1NextBTN1);
    lv_obj_set_width(ui_Page1NextBTN, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height(ui_Page1NextBTN, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_Page1NextBTN, LV_ALIGN_CENTER);
    lv_label_set_text(ui_Page1NextBTN, "NEXT");

    ui_Page1PrevBTN = lv_btn_create(ui_Bubble_Level_Page);
    lv_obj_set_width(ui_Page1PrevBTN, 50);
    lv_obj_set_height(ui_Page1PrevBTN, 25);
    lv_obj_set_x(ui_Page1PrevBTN, 0);
    lv_obj_set_y(ui_Page1PrevBTN, 125);
    lv_obj_set_align(ui_Page1PrevBTN, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_Page1PrevBTN, LV_OBJ_FLAG_SCROLL_ON_FOCUS); /// Flags
    lv_obj_clear_flag(ui_Page1PrevBTN, LV_OBJ_FLAG_SCROLLABLE);    /// Flags
    ui_modern_theme_apply_button_style(ui_Page1PrevBTN);

    ui_Page1PrevBTN1 = lv_label_create(ui_Page1PrevBTN);
    lv_obj_set_width(ui_Page1PrevBTN1, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height(ui_Page1PrevBTN1, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_Page1PrevBTN1, LV_ALIGN_CENTER);
    lv_label_set_text(ui_Page1PrevBTN1, "PREV");

    // --- Bubble Level Specific UI Initialization (Added Code) ---

    // Initialize colors for the bubble level elements using DEADEYE theme
    ui_modern_colors_t colors = ui_modern_colors;
    color_page_bg_bubble = colors.primary_dark;
    color_tube_bg_bubble = colors.primary_light;
    color_bubble_green = colors.accent_green;
    color_bubble_yellow = colors.warning_amber;
    color_bubble_red = colors.accent_red;
    color_text_roll_label = colors.text_primary;
    color_tube_marking_bubble = colors.text_secondary;

    // 1. Create the numerical display label for the roll angle
    ui_RollAngleLabel = lv_label_create(ui_Bubble_Level_Page);
    lv_label_set_text(ui_RollAngleLabel, "0Â°");
    lv_obj_set_style_text_color(ui_RollAngleLabel, color_text_roll_label, LV_PART_MAIN);
    ui_modern_theme_apply_secondary_text_style(ui_RollAngleLabel);
    // Position it above the center of where the canvas will be
    lv_obj_align(ui_RollAngleLabel, LV_ALIGN_CENTER, 0, -10 - (LEVEL_CANVAS_HEIGHT / 2) - 15);

    // 2. Create the canvas for the bubble level
    ui_BubbleLevelCanvas = lv_canvas_create(ui_Bubble_Level_Page);

    // Set buffer for the canvas (LVGL v8.3.11)
    static lv_color_t canvas_buffer[LV_CANVAS_BUF_SIZE_TRUE_COLOR(LEVEL_CANVAS_WIDTH, LEVEL_CANVAS_HEIGHT)];
    lv_canvas_set_buffer(ui_BubbleLevelCanvas, canvas_buffer, LEVEL_CANVAS_WIDTH, LEVEL_CANVAS_HEIGHT, LV_IMG_CF_TRUE_COLOR);

    lv_obj_align(ui_BubbleLevelCanvas, LV_ALIGN_CENTER, 0, -10); // Centered X, Y -10px as requested

    // Initial draw of the bubble level on the canvas
    draw_bubble_level_on_canvas(0.0f);

    // 3. Create an LVGL timer to update the level periodically
    if (ui_level_update_timer == NULL)
    {
        ui_level_update_timer = lv_timer_create(level_update_timer_cb, 250, NULL);
    }
    else
    {
        lv_timer_reset(ui_level_update_timer);
        lv_timer_resume(ui_level_update_timer);
    }
    // --- End of Bubble Level Specific UI Initialization ---

    // Add event callbacks (from your provided .c file)
    lv_obj_add_event_cb(ui_Page1HomeBTN, ui_event_Page1HomeBTN, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_Page1NextBTN1, ui_event_Page1NextBTN1, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_Page1PrevBTN, ui_event_Page1PrevBTN, LV_EVENT_ALL, NULL);
}

void ui_Bubble_Level_Page_screen_destroy(void)
{
    // First, delete the timer associated with this screen's elements
    if (ui_level_update_timer != NULL)
    {
        lv_timer_del(ui_level_update_timer);
        ui_level_update_timer = NULL; // Important to set to NULL after deletion
        // LV_LOG_USER("Bubble level timer deleted.");
    }

    // Now, delete the screen object itself (which also deletes its children)
    if (ui_Bubble_Level_Page)
    { // Check if the screen object exists
        lv_obj_del(ui_Bubble_Level_Page);
        // LV_LOG_USER("ui_Bubble_Level_Page screen object deleted.");
    }

    // NULL screen variables (as per your original destroy function)
    ui_Bubble_Level_Page = NULL;
    ui_BubbleLevelPageLabel = NULL; // Child of ui_Bubble_Level_Page, pointer now invalid
    ui_Page1HomeBTN = NULL;         // Child
    ui_Pg1HomeBTN = NULL;           // Child of ui_Page1HomeBTN
    ui_Page1NextBTN1 = NULL;        // Child
    ui_Page1NextBTN = NULL;         // Child of ui_Page1NextBTN1
    ui_Page1PrevBTN = NULL;         // Child
    ui_Page1PrevBTN1 = NULL;        // Child of ui_Page1PrevBTN

    // NULL out static pointers for bubble level elements as well,
    // as their objects were children of ui_Bubble_Level_Page and are now deleted.
    ui_BubbleLevelCanvas = NULL;
    ui_RollAngleLabel = NULL;
    // ui_level_update_timer is already NULLed above.
}

// --- Bubble Level Helper Functions (Added Code) ---

static void draw_bubble_level_on_canvas(float roll_angle_deg)
{
    if (!ui_BubbleLevelCanvas || !lv_obj_is_valid(ui_BubbleLevelCanvas))
    {
        return;
    }

    float display_angle = roll_angle_deg;
    if (display_angle > MAX_ROLL_ANGLE)
        display_angle = MAX_ROLL_ANGLE;
    if (display_angle < -MAX_ROLL_ANGLE)
        display_angle = -MAX_ROLL_ANGLE;

    lv_canvas_fill_bg(ui_BubbleLevelCanvas, color_page_bg_bubble, LV_OPA_COVER);

    lv_draw_rect_dsc_t tube_dsc;
    lv_draw_rect_dsc_init(&tube_dsc);
    tube_dsc.bg_color = color_tube_bg_bubble;
    tube_dsc.radius = TUBE_BORDER_RADIUS;
    int32_t tube_draw_x = (LEVEL_CANVAS_WIDTH - TUBE_WIDTH) / 2;
    int32_t tube_draw_y = (LEVEL_CANVAS_HEIGHT - TUBE_HEIGHT) / 2;
    lv_canvas_draw_rect(ui_BubbleLevelCanvas, tube_draw_x, tube_draw_y, TUBE_WIDTH, TUBE_HEIGHT, &tube_dsc);

    lv_draw_rect_dsc_t mark_rect_dsc;
    lv_draw_rect_dsc_init(&mark_rect_dsc);
    mark_rect_dsc.bg_color = color_tube_marking_bubble;
    lv_canvas_draw_rect(ui_BubbleLevelCanvas,
                        tube_draw_x + TUBE_WIDTH / 2 - 1,
                        tube_draw_y + 2,
                        2,
                        TUBE_HEIGHT - 4,
                        &mark_rect_dsc);

    // --- Calculate Bubble Position ---
    // The total horizontal distance the center of the bubble can travel
    // MODIFIED: Use BUBBLE_WIDTH instead of BUBBLE_DIAMETER
    int32_t bubble_travel_range_px = TUBE_WIDTH - BUBBLE_WIDTH;
    if (bubble_travel_range_px < 0)
        bubble_travel_range_px = 0; // Prevent negative range

    float normalized_pos = (display_angle + MAX_ROLL_ANGLE) / (2.0f * MAX_ROLL_ANGLE);
    int32_t bubble_offset_in_tube = (int32_t)(normalized_pos * bubble_travel_range_px);

    int32_t bubble_draw_x = tube_draw_x + bubble_offset_in_tube;
    // MODIFIED: Use BUBBLE_HEIGHT for vertical centering
    int32_t bubble_draw_y = tube_draw_y + (TUBE_HEIGHT - BUBBLE_HEIGHT) / 2;

    lv_color_t current_bubble_color;
    float abs_actual_angle = fabsf(roll_angle_deg);

    if (abs_actual_angle <= ui_settings_get_bubble_green_threshold())
    {
        current_bubble_color = color_bubble_green;
    }
    else if (abs_actual_angle <= ui_settings_get_bubble_yellow_threshold())
    {
        current_bubble_color = color_bubble_yellow;
    }
    else
    {
        current_bubble_color = color_bubble_red;
    }

    // --- Draw the Bubble (as an oval) ---
    lv_draw_rect_dsc_t bubble_dsc;
    lv_draw_rect_dsc_init(&bubble_dsc);
    bubble_dsc.bg_color = current_bubble_color;
    // MODIFIED: To make an oval, set radius to half the smaller dimension (BUBBLE_HEIGHT)
    bubble_dsc.radius = BUBBLE_HEIGHT / 2;
    // MODIFIED: Use BUBBLE_WIDTH and BUBBLE_HEIGHT
    lv_canvas_draw_rect(ui_BubbleLevelCanvas,
                        bubble_draw_x,
                        bubble_draw_y,
                        BUBBLE_WIDTH,
                        BUBBLE_HEIGHT,
                        &bubble_dsc);
}

static void level_update_timer_cb(lv_timer_t *timer)
{
    (void)timer;

    if (!ui_Bubble_Level_Page || !lv_obj_is_valid(ui_Bubble_Level_Page) ||
        !ui_RollAngleLabel || !lv_obj_is_valid(ui_RollAngleLabel) ||
        !ui_BubbleLevelCanvas || !lv_obj_is_valid(ui_BubbleLevelCanvas))
    {
        // Stop the timer if any objects are invalid
        if (ui_level_update_timer)
        {
            lv_timer_del(ui_level_update_timer);
            ui_level_update_timer = NULL;
        }
        return;
    }

    float current_roll = get_qmi8658_roll_degrees();

    char angle_text_buf[16];
    snprintf(angle_text_buf, sizeof(angle_text_buf), "%.0fÂ°", current_roll);
    lv_label_set_text(ui_RollAngleLabel, angle_text_buf);

    draw_bubble_level_on_canvas(current_roll);
}
